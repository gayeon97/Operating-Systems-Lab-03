		//save T, the number of tasks
		
		//save R, the number of resource types
		
		//for 0 to R-1, save the R number of units that each represent the number of each resource type available
		
		
		//create an arraylist of tasks of size T: ArrayList<Task> tasks = new ArrayList<>(T);
		/*
		 * for (int i = 0; i < T; i ++) {
		 * 		//create new task of index i
		 * 		Task t = new Task(i);
		 * 
		 * 		//add it to the arrayList of tasks
		 * 		tasks.add(t);
		 * }
		 */
		
		/* then until you reach the end of the line,
		 * you first read the activity & save it to a temporary string, tempActivitiy
		 * the string is one of the following values:
		 * 	initiate
		 *  request
		 *  release
		 *  terminate
		 *  
		 * then for next 4 integers:
		 *  	for initiate: task-number, delay, resource-type, initial-claim
		 *  	for request: task-number, delay, resource-type, number-requested
		 *  	for release: task-number, delay, resource-type, number-released
		 *  	for terminate: task-number, delay, unused, unused
		 * store it into an arraylist of integers: ArrayList<Integer> activityInfo = new ArrayList<>();
		 * 	activityInfo.add(task-number);
		 *  activityInfo.add(delay);
		 *  activityInfo.add(3rd value);
		 *  activityInfo.add(4th value);
		 * 
		 * get the correct task from the ArrayList<Task> tasks using the task-number - 1
		 * 		Task tempTask = tasks.get(task-number - 1);
		 * 
		 * save the tempString and arraylist of integers depending on the tempString value
		 * 	if (tempString.contains("initiate") {
		 * 		tempTask.getAllInitActivities.add(
		 * 	} else if (tempString.contains("request") {
		 * 		tempTask.getAllInitActivities.add(
		 * 	} else if (tempString.contains("release") {
		 * 		tempTask.getAllInitActivities.add(
		 * 	} else if (tempString.contains("terminate") {
		 * 		tempTask.getAllInitActivities.add(
		 * 	}
		 * 
		 */
		 
		 
		 //		File newFile = null;
//		
//		try {
//			System.out.println(args[0]);
//			newFile = new File(args[0]);
//		} catch (Exception e){
//			System.out.println("Please make sure that you are giving the file name as a command line argument.");
//		}
		 
		 
				//create a new Activity pair: (activityName, listOfActivityInfo)
				//LinkedHashMap<String, ArrayList<Integer>> activity = new LinkedHashMap<>();
				//activity.put(tempActivityState + placeholder, activityInfo);
				
				
				
//		//print out each Task info after the positive resource manager finishes
//		System.out.printf("\n-----------------------------\n%14s\n","FIFO");
//		for (Task ee: tasksOptimistic) {
//			ee.printTaskInfo();
//			totalTime += ee.getTimeTerminated();
//			totalWaitingTime += ee.getHold();
//		}
//		//Print the total time for all tasks, the total waiting time, and the overall percentage of time spent waiting
//		System.out.printf("total %8d %4d %5d%s",totalTime,totalWaitingTime,100,"%");
//		//System.out.printf("total %8d %4d %5d%s",totalTime,totalWaitingTime,(int) Math.rint((totalTime/totalWaitingTime) * 100),"%");
//		System.out.println("\n-----------------------------");
				
				
				
				
FOR DEADLOCK
			
//			//check for deadlock
//			boolean canExecute = false;
//			//if not a single task executed and the cycle is > 1 (meaning, some time has passed since the tasks' activities has been first executed)
//			if ( !taskExecuted && cycle > 1) { //we encountered a deadlock!
//				//try to resolve the deadlock
//				while (!canExecute) {
//					//get the Task with the lowest index
//					int taskIndexToAbort = tasksBanker.get(0).getIndex(); //initializing the lowest index
//					int indexInTasksOpt = 0; //the index of the Task with the lowest index WITHIN the list of tasks for Opt. resource manager
//					System.out.println("starts with Task: " + (taskIndexToAbort+1));
//					for (int m = 1; m < tasksBanker.size(); m ++) {
//						int nextIndex = tasksBanker.get(m).getIndex();
//						if (taskIndexToAbort > nextIndex) { //if the currentTask's index is GREATER than the nextTask's index
//							taskIndexToAbort = nextIndex; //set the currentTask to the nextTask's index that is smaller
//							indexInTasksOpt = m; //save the position of the updated currentTask's WITHIN the list of tasks for Opt. resource manager
//							System.out.println("this is the task index to abort: " + taskIndexToAbort);
//							System.out.println("this is the task index in tasksOpt: " + indexInTasksOpt);
//						}
//					}
//					System.out.println("This is the task index to abort: " + taskIndexToAbort);
//					System.out.println("that task has index in tasksOpt: " + indexInTasksOpt);
//					
//					//this is the task to be aborted
//					Task taskAbort = tasksBanker.get(indexInTasksOpt);
//					//System.out.println(taskAbort.getActivities().get(0).get("request"));
//					
//					//set task's Abort to True
//					taskAbort.setAbort(true);
//					
//					//release the resources of the task to be aborted
//					HashMap<Integer,Integer> itsHeldRsrcs = taskAbort.getResourcesHeld();
//					for (int n = 0; n < itsHeldRsrcs.size(); n ++) {
//						int resourceHeld = itsHeldRsrcs.get(n); //get the units held of the current resource type
//						int resourceReturned = listOfReturnedUnitsOfEachResource.get(n); //get the currently all returned units of the current resource type
//						System.out.println("this is the resource held: " + resourceHeld);
//						System.out.println(resourceReturned);
//						
//						//add the resource release by the current task to the total units returned for the current resource
//						resourceReturned += resourceHeld;
//						listOfReturnedUnitsOfEachResource.set(n, resourceReturned);
//						System.out.printf("The returnedResource %d now has %d units\n",n, resourceReturned);
//					}
//					
//					System.out.println("the task that will be aborted is has index: " + taskAbort.getIndex());
//					
//					//store the current task to the right index in the finalized list holding tasks for Opt. resource manager
//					tasksFinalizedOpt.set(taskAbort.getIndex(),taskAbort);
//					//remove the CURRENT TASK from the list of tasks since it is ABORTED
//					tasksBanker.remove(indexInTasksOpt);
//					
//					//go through the modified list of tasks to see if deadlock is resolved
//					for (int b = 0; b < tasksBanker.size(); b ++) {
//						Task t = tasksBanker.get(b);
//						
//						HashMap<String, ArrayList<Integer>> activity0 = t.getActivities().get(0);
//						for (Map.Entry m : activity0.entrySet()) { 
//							System.out.println(m.getKey()+": "+m.getValue().toString()); 
//							//System.out.println((String) m.getKey());
//							ArrayList<Integer> info = activity0.get((String) m.getKey()); //get activity info of current task
//							System.out.println(info.get(3));
//							System.out.println(listOfReturnedUnitsOfEachResource.get(info.get(2)-1));
//							//if the sum of the units of current resource type available and the units of current resource type released
//							//is enough to satisfy the current task's request
//							if (info.get(3) <= listOfReturnedUnitsOfEachResource.get(info.get(2)-1) + listOfUnitsOfEachResource.get(info.get(2)-1)) {
//								canExecute = true; //the deadlock is resolved and you can execute
//							}					
//						}						
//					} //end of the for loop for going through the modified list of tasks
//				} //end of the while loop for resolving the deadlock
//
//			} else { //a Task has been running, i.e. NO deadlock
//				taskExecuted = false; //reset the taskExecuted to false for the next cycle
//			}


from line 791 of Part4.java
//								//check if the current task's resources requested DOES NOT EXCEED its claim
//								if (resourceRequested <= resourceClaimed) {
//									//System.out.printf("Task %d's resource requested DOES NOT EXCEED its claim!\n",currTask.getTaskNum());
//									//System.out.printf("Task %d's requested resources: %d VS. claim: %d .\n",currTask.getTaskNum(),resourceRequested,resourceClaimed);
//
//									//System.out.printf("GRANTED: Task %d's request for Resource %d!\n",currTask.getTaskNum(),resourceIndex+1);
//
//									//reset the requestDelay to 0
//									currTask.resetRequestdelay();
//
//									//calculate the claim remaining for the current requested resource type
//									resourceClaimed -= resourceRequested;
//									//update the list that stores the claims of each resource type
//									allClaims.put(resourceIndex, resourceClaimed);
//									//System.out.printf("There are %d claim LEFT of Resource %d\n",allClaims.get(resourceIndex),resourceIndex+1);						
//									//set the updated list of current task that stores the claims of each resource type 
//									currTask.setClaims(allClaims);
//									for (Map.Entry m:currTask.getClaims().entrySet()) { 
//										//System.out.printf("Resource %d's remaining claim: %d\n",(int)m.getKey() + 1,m.getValue()); 
//										//System.out.printf("Task %d's Resource #%d held units: %d\n",currTask.getTaskNum(),(int)m.getKey() + 1,m.getValue());
//									} 
//
//									for (Map.Entry m:currTask.getResourcesHeld().entrySet()) { 
//										//System.out.printf("Resource %d's remaining claim: %d\n",(int)m.getKey() + 1,m.getValue()); 
//										//System.out.printf("Task %d's Resource #%d held units: %d\n",currTask.getTaskNum(),(int)m.getKey() + 1,m.getValue());
//										//System.out.printf("before: Task %d currently holds %d of resource %d\n",currTask.getTaskNum(),m.getValue(),(int)m.getKey()+1);
//									} 
//
//									//set the units requested for the resource as the value for the resourceHeld of requested resource type
//									//this represents that current task is holding additional many units of the resource it has requested
//									currTask.getResourcesHeld().put(resourceIndex,currTask.getResourcesHeld().get(resourceIndex)+resourceRequested);
//									//System.out.printf("now: Task %d currently holds %d of resource %d\n",currTask.getTaskNum(),currTask.getResourcesHeld().get(resourceIndex),resourceIndex+1);
//
//									//calculate the remaining resources available for the Opt. resource manager
//									int newResourceAvail = resourceAvail - resourceRequested;
//									//System.out.printf("There are %d units LEFT of Resource %d\n",newResourceAvail,resourceIndex+1);
//
//									//update the list that stores the available units of each resource type
//									listOfUnitsOfEachResource.set(resourceIndex, newResourceAvail);
//
//									//the request has been granted, so remove the activity from the activities list
//									currTask.getActivities().remove(0);
//
//									//pop the current Task and add it to the executedTasks list
//									executedTasks.add(tasksBanker.remove(i));
//									i--; //do this so the order of reading from the list of tasks isn't disturbed
//									//System.out.println("THE TASK HAS BEEN POPPED\n");
//
//								} else { //the current task's resources requested DOES EXCEED its claim --> ERROR!
//									//System.out.printf("ERROR: Task %d's RESOURCE REQUESTED does EXCEED its claim!\n\n",currTask.getTaskNum());
//
//									String errorInfo = "";
//
//									//so ABORT
//									currTask.setAbort(true);
//
//									//release all the resources of the task to be aborted
//									HashMap<Integer,Integer> itsHeldRsrcs = currTask.getResourcesHeld();
//									for (int n = 0; n < itsHeldRsrcs.size(); n ++) {
//										int resourceHeld = itsHeldRsrcs.get(n); //get the units held of the current resource type
//										int resourceReturned = listOfReturnedUnitsOfEachResource.get(n); //get the currently all returned units of the current resource type
//										//System.out.println("this is the resource held: " + resourceHeld);
//										//System.out.println(resourceReturned);
//
//										//add the resource release by the current task to the total units returned for the current resource
//										resourceReturned += resourceHeld;
//										listOfReturnedUnitsOfEachResource.set(n, resourceReturned);
//										//System.out.printf("The returnedResource %d now has %d units\n",n, resourceReturned);
//
//										errorInfo += String.format(" %d unit of resource %d", resourceReturned, n+1);
//									}
//
//									//store the current task to the right index in the finalized list holding tasks for Opt. resource manager
//									tasksFinalizedBkr.set(currTask.getIndex(), currTask);
//									//remove the CURRENT TASK from the list of tasks since it is COMPLETED
//									tasksBanker.remove(currTask);
//
//									error += String.format("During cycle %d-%d of Banker's algorithms\n",cycle-1,cycle);
//									error += String.format("\tTask %d's request exceeds its claim; aborted;",currTask.getTaskNum());
//									error += errorInfo;
//									error += " available next cycle\n";
//								}
